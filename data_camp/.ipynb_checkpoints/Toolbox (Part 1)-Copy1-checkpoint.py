{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Writing your own functions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## String in Python"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3\n",
      "111\n"
     ]
    }
   ],
   "source": [
    "object1 = 1 * 3\n",
    "object2 = \"1\" * 3\n",
    "print(object1)\n",
    "print(object2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Recapping built-in functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n",
      "<class 'int'>\n",
      "<class 'NoneType'>\n"
     ]
    }
   ],
   "source": [
    "x1 = 1\n",
    "x2 = print(1)\n",
    "print(type(x1))\n",
    "print(type(x2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Write a simple function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define the function shout\n",
    "def shout():\n",
    "    \"\"\"Print a string with three exclamation marks\"\"\"\n",
    "    \n",
    "    # concatenate the strings: shout_word\n",
    "    shout_word = 'I am a Data Scientist' + '!!!'\n",
    "    \n",
    "    # print shout_word\n",
    "    print(shout_word)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "I am a Data Scientist!!!\n"
     ]
    }
   ],
   "source": [
    "# call shout\n",
    "shout()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on function shout in module __main__:\n",
      "\n",
      "shout()\n",
      "    Print a string with three exclamation marks\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(shout)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Single-parameter functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "# adding a parameter\n",
    "def shout(word):\n",
    "    \"\"\"Print a string with three exclamation marks\"\"\"\n",
    "    \n",
    "    # concatenate the strings: shout_word\n",
    "    shout_word = word + \"!!!\"\n",
    "    \n",
    "    # print shout_word\n",
    "    print(shout_word)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Show me the money!!!\n"
     ]
    }
   ],
   "source": [
    "shout('Show me the money')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Functions that return single values\n",
    "\n",
    "'return' lets you have value with type unlike print giving you 'NoneType'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define shout with the parameter, word\n",
    "def shout2(word):\n",
    "    \"\"\"Print a string with three exclamation marks\"\"\"\n",
    "    \n",
    "    # concatenate the strings: shout_word\n",
    "    shout_word = word + \"!!!\"\n",
    "    \n",
    "    # replace print with return\n",
    "    return shout_word"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "when using print!!!\n",
      "<class 'NoneType'>\n",
      "<class 'str'>\n"
     ]
    }
   ],
   "source": [
    "print_use = shout('when using print')\n",
    "return_use = shout2('when using return')\n",
    "print(type(print_use))\n",
    "print(type(return_use))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Functions with multiple parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define shout with parameters word1 and word2\n",
    "def shout(word1, word2):\n",
    "    \"\"\"Concatenate strings with three exclamanation marks\"\"\"\n",
    "    # concatenate word1 with '!!!': shout1\n",
    "    shout1 = word1 + '!!!'\n",
    "    # concatenate word2 with '!!!': shout2\n",
    "    shout2 = word2 + '!!!'\n",
    "    \n",
    "    # concatenate shout1 and shout2: new shout\n",
    "    new_shout = shout1 + shout2\n",
    "    \n",
    "    # return new shout\n",
    "    return new_shout"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Hello!!!Ciao!!!\n"
     ]
    }
   ],
   "source": [
    "# pass 'Hello' and 'Ciao' to shout(): yell\n",
    "yell = shout('Hello', 'Ciao')\n",
    "print(yell)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## A brief introduction to tuples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(1999, 2019, 2029)\n"
     ]
    }
   ],
   "source": [
    "nums = (2009, 2019, 2029)\n",
    "\n",
    "# unpack nums into num1, num2, num3\n",
    "num1, num2, num3 = nums\n",
    "\n",
    "# replace the first element\n",
    "even_nums = (1999, num2, num3)\n",
    "\n",
    "# print\n",
    "print(even_nums)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Functions that return multiple values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "def shout_all(word1, word2):\n",
    "    \n",
    "    # concatenate word1 with '!!!': shout1\n",
    "    shout1 = word1 + '!!!'\n",
    "    \n",
    "    # concatenate word2 with '!!!': shout2\n",
    "    shout2 = word2 + '!!!'\n",
    "    \n",
    "    #construct a tuple with shout1 and shout2: shout_words\n",
    "    shout_words = (shout1, shout2)\n",
    "    \n",
    "    # return shout_words\n",
    "    return shout_words # the same with shout1, shout2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Data!!!\n",
      "Science!!!\n"
     ]
    }
   ],
   "source": [
    "yell1, yell2 = shout_all('Data', 'Science')\n",
    "\n",
    "# print yell1, yell2\n",
    "print(yell1)\n",
    "print(yell2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Bringing it all together (1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.read_csv('../dataset/sp500_Stock/sp500_companies.csv')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "# initialize any empty dictionary\n",
    "sector_count = {}\n",
    "\n",
    "# iterate over 'Sector' column in DataFrame\n",
    "for entry in df['Sector']:\n",
    "    \n",
    "    # If the sector is in sector_count, add 1\n",
    "    if entry in sector_count.keys():\n",
    "        sector_count[entry] += 1\n",
    "        \n",
    "    else:\n",
    "        sector_count[entry] = 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'Technology': 73, 'Communication Services': 27, 'Consumer Cyclical': 63, 'Financial Services': 68, 'Healthcare': 65, 'Consumer Defensive': 35, 'Energy': 21, 'Industrials': 72, 'Basic Materials': 21, 'Utilities': 28, 'Real Estate': 29}\n"
     ]
    }
   ],
   "source": [
    "print(sector_count)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "# create function\n",
    "def count_cate(df, col):\n",
    "    \"\"\"Return a dictionary with counts of occurrences as value for each key.\"\"\"\n",
    "    \n",
    "    # initialize an empty dictionary\n",
    "    dict = {}\n",
    "    \n",
    "    # iterate over column in dataframe\n",
    "    for entry in df[col]:\n",
    "        \n",
    "        # if the entry is in dictionary, add 1\n",
    "        if entry in dict.keys():\n",
    "            dict[entry] += 1\n",
    "        else:\n",
    "            dict[entry] = 1\n",
    "            \n",
    "    # return the dictionary\n",
    "    return dict"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'United States': 482, 'Ireland': 10, 'United Kingdom': 3, 'Switzerland': 4, 'Netherlands': 1, 'Israel': 1, 'Bermuda': 1}\n"
     ]
    }
   ],
   "source": [
    "# call count_cate\n",
    "result = count_cate(df, 'Country')\n",
    "print(result)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Default arguments, variable-length arguments and scope"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "5\n",
      "3\n",
      "None\n"
     ]
    }
   ],
   "source": [
    "# scope\n",
    "\n",
    "num = 5\n",
    "\n",
    "def func1():\n",
    "    num = 3\n",
    "    print(num)\n",
    "\n",
    "print(num)\n",
    "print(func1())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "5\n",
      "10\n",
      "6\n"
     ]
    }
   ],
   "source": [
    "# if you put global within function, the variable in global scope changes\n",
    "\n",
    "num = 5\n",
    "\n",
    "def func2():\n",
    "    global num\n",
    "    double_num = num * 2\n",
    "    num = 6\n",
    "    return double_num\n",
    "\n",
    "print(num)\n",
    "print(func2())\n",
    "print(num)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## the keyword global"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define a horoscope\n",
    "horoscope = 'Gemini'\n",
    "\n",
    "# make the function and use the keyword, global\n",
    "def horoscope_is(word):\n",
    "    \"\"\"print the horoscope that is typed\"\"\"\n",
    "    global horoscope\n",
    "    print(word)\n",
    "    horoscope = 'Taurus'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Gemini\n",
      "Virgo\n",
      "None\n",
      "Taurus\n"
     ]
    }
   ],
   "source": [
    "# print the horoscope variable\n",
    "print(horoscope)\n",
    "\n",
    "# call a function\n",
    "print(horoscope_is('Virgo'))\n",
    "\n",
    "# print the horoscpe variable again\n",
    "print(horoscope)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Python's built-in scope"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['ArithmeticError',\n",
       " 'AssertionError',\n",
       " 'AttributeError',\n",
       " 'BaseException',\n",
       " 'BlockingIOError',\n",
       " 'BrokenPipeError',\n",
       " 'BufferError',\n",
       " 'BytesWarning',\n",
       " 'ChildProcessError',\n",
       " 'ConnectionAbortedError',\n",
       " 'ConnectionError',\n",
       " 'ConnectionRefusedError',\n",
       " 'ConnectionResetError',\n",
       " 'DeprecationWarning',\n",
       " 'EOFError',\n",
       " 'Ellipsis',\n",
       " 'EnvironmentError',\n",
       " 'Exception',\n",
       " 'False',\n",
       " 'FileExistsError',\n",
       " 'FileNotFoundError',\n",
       " 'FloatingPointError',\n",
       " 'FutureWarning',\n",
       " 'GeneratorExit',\n",
       " 'IOError',\n",
       " 'ImportError',\n",
       " 'ImportWarning',\n",
       " 'IndentationError',\n",
       " 'IndexError',\n",
       " 'InterruptedError',\n",
       " 'IsADirectoryError',\n",
       " 'KeyError',\n",
       " 'KeyboardInterrupt',\n",
       " 'LookupError',\n",
       " 'MemoryError',\n",
       " 'ModuleNotFoundError',\n",
       " 'NameError',\n",
       " 'None',\n",
       " 'NotADirectoryError',\n",
       " 'NotImplemented',\n",
       " 'NotImplementedError',\n",
       " 'OSError',\n",
       " 'OverflowError',\n",
       " 'PendingDeprecationWarning',\n",
       " 'PermissionError',\n",
       " 'ProcessLookupError',\n",
       " 'RecursionError',\n",
       " 'ReferenceError',\n",
       " 'ResourceWarning',\n",
       " 'RuntimeError',\n",
       " 'RuntimeWarning',\n",
       " 'StopAsyncIteration',\n",
       " 'StopIteration',\n",
       " 'SyntaxError',\n",
       " 'SyntaxWarning',\n",
       " 'SystemError',\n",
       " 'SystemExit',\n",
       " 'TabError',\n",
       " 'TimeoutError',\n",
       " 'True',\n",
       " 'TypeError',\n",
       " 'UnboundLocalError',\n",
       " 'UnicodeDecodeError',\n",
       " 'UnicodeEncodeError',\n",
       " 'UnicodeError',\n",
       " 'UnicodeTranslateError',\n",
       " 'UnicodeWarning',\n",
       " 'UserWarning',\n",
       " 'ValueError',\n",
       " 'Warning',\n",
       " 'ZeroDivisionError',\n",
       " '__IPYTHON__',\n",
       " '__build_class__',\n",
       " '__debug__',\n",
       " '__doc__',\n",
       " '__import__',\n",
       " '__loader__',\n",
       " '__name__',\n",
       " '__package__',\n",
       " '__spec__',\n",
       " 'abs',\n",
       " 'all',\n",
       " 'any',\n",
       " 'ascii',\n",
       " 'bin',\n",
       " 'bool',\n",
       " 'breakpoint',\n",
       " 'bytearray',\n",
       " 'bytes',\n",
       " 'callable',\n",
       " 'chr',\n",
       " 'classmethod',\n",
       " 'compile',\n",
       " 'complex',\n",
       " 'copyright',\n",
       " 'credits',\n",
       " 'delattr',\n",
       " 'dict',\n",
       " 'dir',\n",
       " 'display',\n",
       " 'divmod',\n",
       " 'enumerate',\n",
       " 'eval',\n",
       " 'exec',\n",
       " 'filter',\n",
       " 'float',\n",
       " 'format',\n",
       " 'frozenset',\n",
       " 'get_ipython',\n",
       " 'getattr',\n",
       " 'globals',\n",
       " 'hasattr',\n",
       " 'hash',\n",
       " 'help',\n",
       " 'hex',\n",
       " 'id',\n",
       " 'input',\n",
       " 'int',\n",
       " 'isinstance',\n",
       " 'issubclass',\n",
       " 'iter',\n",
       " 'len',\n",
       " 'license',\n",
       " 'list',\n",
       " 'locals',\n",
       " 'map',\n",
       " 'max',\n",
       " 'memoryview',\n",
       " 'min',\n",
       " 'next',\n",
       " 'object',\n",
       " 'oct',\n",
       " 'open',\n",
       " 'ord',\n",
       " 'pow',\n",
       " 'print',\n",
       " 'property',\n",
       " 'range',\n",
       " 'repr',\n",
       " 'reversed',\n",
       " 'round',\n",
       " 'set',\n",
       " 'setattr',\n",
       " 'slice',\n",
       " 'sorted',\n",
       " 'staticmethod',\n",
       " 'str',\n",
       " 'sum',\n",
       " 'super',\n",
       " 'tuple',\n",
       " 'type',\n",
       " 'vars',\n",
       " 'zip']"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# import\n",
    "import builtins\n",
    "\n",
    "# see a list of all the names in the module, builtins\n",
    "dir(builtins)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Nested Functions 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "('Eat!!!', 'Pray!!!', 'Love!!!')\n"
     ]
    }
   ],
   "source": [
    "# define a function\n",
    "def three_shout(word1, word2, word3):\n",
    "    \"\"\"Returna a tuple of strings concatenated with'!!!'.'\"\"\"\n",
    "    \n",
    "    # define a inner\n",
    "    def inner(word):\n",
    "        word = word + '!!!'\n",
    "        return word\n",
    "    \n",
    "    # return a tuples of strings\n",
    "    return(inner(word1), inner(word2), inner(word3))\n",
    "\n",
    "# call three_shout() and print\n",
    "print(three_shout('Eat', 'Pray', 'Love'))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Nested Functions 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define echo\n",
    "def echo(n):\n",
    "    \"\"\"Return the inner_echo function.\"\"\"\n",
    "    \n",
    "    # define inner_echo\n",
    "    def inner_echo(word1):\n",
    "        echo_word = word1 * n\n",
    "        return echo_word\n",
    "    \n",
    "    # return inner_echo\n",
    "    return inner_echo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "babybaby babybabybaby\n"
     ]
    }
   ],
   "source": [
    "# calll echo\n",
    "twice = echo(2)  # nested function (that is, inner_echo) remembers the state of its enclosing scope(that is 2) when called\n",
    "thrice = echo(3)\n",
    "\n",
    "# call twice and thrice\n",
    "print(twice('baby'), thrice('baby'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'hahahahahahahahahaha'"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a = echo(10)\n",
    "a('ha')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The keyword nonlocal and nested functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define greetings\n",
    "def greetings(word):\n",
    "    \"\"\"print the greeting\"\"\"\n",
    "    # define the variable 'word'\n",
    "    word1 =  word\n",
    "    print(word1)\n",
    "    \n",
    "    # define in_italian\n",
    "    def in_italian():\n",
    "        \"\"\"Alter a variable in the enclosing scope\"\"\"\n",
    "        # use word in nonlocal scope\n",
    "        nonlocal word1\n",
    "        \n",
    "        # change word to italian greeting\n",
    "        word1 = 'ciao'\n",
    "        \n",
    "    # call the function, in_italian\n",
    "    in_italian()   # word = 'hello' -> 'ciao'\n",
    "    \n",
    "    # print the word\n",
    "    print(word1)    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "hello\n",
      "ciao\n"
     ]
    }
   ],
   "source": [
    "# call the function greetings\n",
    "greetings('hello')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Functions with one default argument"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define a function\n",
    "def load_cal(quantity, MOQ = 10):\n",
    "    \"\"\"Calculate the quantity to satisfy minimum order quantity.\"\"\"\n",
    "    # calculate a quantity meeting MOQ\n",
    "    new_quantity = MOQ * (int(quantity/MOQ) + 1)\n",
    "    return new_quantity"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "default: 250\n",
      "argument updated: 144\n"
     ]
    }
   ],
   "source": [
    "# call the function with just quantity\n",
    "print('default:', load_cal(246))\n",
    "# call the function with different argument\n",
    "print('argument updated:', load_cal(135, MOQ =36))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on function load_cal in module __main__:\n",
      "\n",
      "load_cal(quantity, MOQ=10)\n",
      "    Calculate the quantity to satisfy minimum order quantity.\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(load_cal)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Functions with multiple default arguments"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define load_cal() with interval\n",
    "def load_cal(quantity, MOQ = 10, interval = False, interval_unit = 0):\n",
    "    \"\"\"Calculate the quantity to satisfy minimum order quantity.\"\"\"\n",
    "    # calcuLlate a quantity meeting MOQ\n",
    "    if LLLLinterval is True:\n",
    "        new_quantity = MOQ + (interval_unit * (int((quantity - MOQ)/interval_unit) + 1))\n",
    "    \n",
    "    else:\n",
    "        new_quantity = MOQ * (int(quantity/MOQ) + 1)\n",
    "    return new_quantity"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "MOQ 36, Interval 12: 936\n"
     ]
    }
   ],
   "source": [
    "print('MOQ 36, Interval 12:', load_cal(934, MOQ = 36, interval = True, interval_unit = 12))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Functions with variable-length arguments (*args)\n",
    "\n",
    "- use when you don't know how many arguments a user will pass\n",
    "- the arguments passed to a function call into a tuple called args in the function body"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define gibberish\n",
    "def gibberish(*args):\n",
    "    \"\"\"Concatenate strings in *args together.\"\"\"\n",
    "    \n",
    "    # initialize an empty string: hocuspocus\n",
    "    hocuspocus = ''\n",
    "    \n",
    "    # concatenate the strings in args\n",
    "    for word in args:\n",
    "        hocuspocus += word\n",
    "        \n",
    "    return hocuspocus"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "lumos\n",
      "kimsuanmoogeobukiwadooroomi\n"
     ]
    }
   ],
   "source": [
    "# call the function gibberish\n",
    "print(gibberish('lumos'))\n",
    "print(gibberish('kim', 'suanmoo','geobukiwa', 'dooroomi'))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Functions with variable-length keyword arguments (**kwargs)\n",
    "\n",
    "- kwargs is a dictionary"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define the function, report_status\n",
    "def report_status(**kwargs):\n",
    "    \"\"\"Print out the status of stocks\"\"\"\n",
    "    \n",
    "    # iterate over the key-value pairs of kwargs\n",
    "    for key, value in kwargs.items():\n",
    "        \n",
    "        # print out the keys and values, separated by a underbar '_'\n",
    "        print(key, '_', value)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "name _ Amazon\n",
      "ticker _ AMZN\n",
      "stock_price _ 3152\n"
     ]
    }
   ],
   "source": [
    "# call the function, report_status\n",
    "report_status(name = 'Amazon', ticker = 'AMZN', stock_price = 3152)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Bringinng it all together(1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [],
   "source": [
    "# create a list of foods\n",
    "list1 = ['ramen', 'sushi', 'pizza', 'pizza', 'ramen', 'bibimbab', 'kimchijjigae', 'galbitang']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "# create the function, count_entries\n",
    "def count_entries(data):\n",
    "    \"\"\"Create a dictionary with counts of occurences as value for each key.\"\"\"\n",
    "    \n",
    "    # initialize an empty dictionary\n",
    "    count_dict = {}\n",
    "    \n",
    "    # iterate over the data\n",
    "    for value in data:\n",
    "        # if value is in count_dict, add 1\n",
    "        if value in count_dict.keys():\n",
    "            count_dict[value] += 1\n",
    "        else:\n",
    "            count_dict[value] = 1\n",
    "        \n",
    "    # return the count_dict dictionary\n",
    "    return count_dict"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'ramen': 2,\n",
       " 'sushi': 1,\n",
       " 'pizza': 2,\n",
       " 'bibimbab': 1,\n",
       " 'kimchijjigae': 1,\n",
       " 'galbitang': 1}"
      ]
     },
     "execution_count": 43,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# call the function, count_entries\n",
    "count_entries(list1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## bring it all together(2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [],
   "source": [
    "# create another list of food\n",
    "list2 = ['phat thai', 'chicken tikka masala', 'nasi goreng', 'nasi goreng', 'pho', 'pho', 'spring roll', 'phat thai']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define count_entries()\n",
    "def count_entries(*args):\n",
    "    \n",
    "    # initialize an empty dictionary: count_dict\n",
    "    count_dict = {}\n",
    "    \n",
    "    # iterate over list name in args\n",
    "    for list in args:\n",
    "        \n",
    "        # iterate over the list\n",
    "        for value in list:\n",
    "            if value in count_dict.keys():\n",
    "                count_dict[value] += 1\n",
    "            else:\n",
    "                count_dict[value] = 1\n",
    "    \n",
    "    return count_dict"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'ramen': 2,\n",
       " 'sushi': 1,\n",
       " 'pizza': 2,\n",
       " 'bibimbab': 1,\n",
       " 'kimchijjigae': 1,\n",
       " 'galbitang': 1,\n",
       " 'phat thai': 2,\n",
       " 'chicken tikka masala': 1,\n",
       " 'nasi goreng': 2,\n",
       " 'pho': 2,\n",
       " 'spring roll': 1}"
      ]
     },
     "execution_count": 46,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# call the function with multiple arguments\n",
    "count_entries(list1, list2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Lambda functions and error-handling"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "lambda function: a quicker way to write a function, but potentially dirty way, so it is advised to use them all the time\n",
    "\n",
    "When to use a lambda function?\n",
    "with **Map Function** which takes two arguments: a function & sequence like list\n",
    "Use this function without naming them (def needs to be saved in environment to use, but lambda doesn't.) -> In this case, we refer to such lambda function as anonymous functions.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Writing a lambda function you already know"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define a function\n",
    "def echo_word(word1, echo):\n",
    "    \"\"\"Concatenate echo copies of word1.\"\"\"\n",
    "    words = word1 * echo\n",
    "    return words"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'hellohello'"
      ]
     },
     "execution_count": 48,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# write the function, echo_word using lambda\n",
    "echo_word = lambda word1, echo: word1 * echo\n",
    "echo_word('hello', 2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Map() and lambda functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [],
   "source": [
    "# apply map function to list\n",
    "shout_obj = map(lambda a: a + '!!', list2)\n",
    "\n",
    "# convert the map object to the list.\n",
    "shout_list = [*shout_obj]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Filter() and lambda functions\n",
    "\n",
    "- the function. filter() offers a way to filter out elements from a list that don't satisfy certain criteria."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['phat thai',\n",
       " 'chicken tikka masala',\n",
       " 'nasi goreng',\n",
       " 'nasi goreng',\n",
       " 'spring roll',\n",
       " 'phat thai']"
      ]
     },
     "execution_count": 67,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# use filter() to apply a lambda function over list2: result\n",
    "\n",
    "result = filter(lambda a: len(a) >= 4, list2)\n",
    "result_list = [*result]\n",
    "result_list"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Reduce() and lambda functions\n",
    "\n",
    "- returns a single value as a result.\n",
    "- need to import it from functools module "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'ramensushipizzapizzaramenbibimbabkimchijjigaegalbitang'"
      ]
     },
     "execution_count": 68,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from functools import reduce\n",
    "\n",
    "# use reduce() to apply a lambda function over list1\n",
    "result = reduce(lambda item1, item2 : item1 + item2, list1)\n",
    "result"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## About errors"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "https://docs.python.org/3/library/exceptions.html\n",
    "\n",
    "- TypeError <br>\n",
    "exception TypeError\n",
    "Raised when an operation or function is applied to an object of inappropriate type. The associated value is a string giving details about the type mismatch.\n",
    "- ValueError <br>\n",
    "exception ValueError\n",
    "Raised when an operation or function receives an argument that has the right type but an inappropriate value, and the situation is not described by a more precise exception such as IndexError.\n",
    "\n",
    "* Passing arguments of the wrong type (e.g. passing a list when an int is expected) should result in a TypeError, but passing arguments with the wrong value (e.g. a number outside expected boundaries) should result in a ValueError."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Error handling with try-except"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define shout_echo\n",
    "def shout_echo(word1, echo = 1):\n",
    "    \"\"\"Concatenate echo copies of word1 and three exclamation marks at the end of the string.\"\"\"\n",
    "    \n",
    "    # initialize empty strings: echo_word, shout_words\n",
    "    echo_word = ''\n",
    "    shout_word = ''\n",
    "    \n",
    "    # add exception handling with try-except\n",
    "    try:\n",
    "        # concatenate echo copies of word1 using *\n",
    "        echo_word = word1 * echo\n",
    "        \n",
    "        # concatenate '!!!' to echo_word\n",
    "        shout_word = echo_word + '!!!'\n",
    "        \n",
    "    except:\n",
    "        # print error message\n",
    "        print('word1 should be a string and echo must be an integer.')\n",
    "    return shout_word"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "word1 should be a string and echo must be an integer.\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "''"
      ]
     },
     "execution_count": 75,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "shout_echo(1, 3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Error handling by raising an error\n",
    "\n",
    "- using 'raise'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define shout_echo\n",
    "def shout_echo(word1, echo = 1):\n",
    "    \"\"\"Concatenate echo copies of word1 and three exclamation marks at the end of the string.\"\"\"\n",
    "    \n",
    "    # initialize empty strings: echo_word, shout_words\n",
    "    echo_word = ''\n",
    "    shout_word = ''\n",
    "    \n",
    "    # raise an error with raise\n",
    "    if echo < 0:\n",
    "        raise ValueError('echo must be greater than or equal to 0')\n",
    "            \n",
    "    # concatenate echo copies of word1 using *\n",
    "    echo_word = word1 * echo\n",
    "        \n",
    "    # concatenate '!!!' to echo_word\n",
    "    shout_word = echo_word + '!!!'\n",
    "        \n",
    "    return shout_word"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "echo must be greater than or equal to 0",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-79-a4bd90d3ccf4>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mshout_echo\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'Jadore'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m-\u001b[0m\u001b[0;36m10\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m<ipython-input-78-407636ebc72e>\u001b[0m in \u001b[0;36mshout_echo\u001b[0;34m(word1, echo)\u001b[0m\n\u001b[1;32m      9\u001b[0m     \u001b[0;31m# raise an error with raise\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     10\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mecho\u001b[0m \u001b[0;34m<\u001b[0m \u001b[0;36m0\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 11\u001b[0;31m         \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'echo must be greater than or equal to 0'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     12\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     13\u001b[0m     \u001b[0;31m# concatenate echo copies of word1 using *\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mValueError\u001b[0m: echo must be greater than or equal to 0"
     ]
    }
   ],
   "source": [
    "shout_echo('Jadore', -10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Bringing it all together(1): filter()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['sushi', 'pizza', 'pizza', 'bibimbab', 'kimchijjigae', 'galbitang']"
      ]
     },
     "execution_count": 80,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# select food with 'i'\n",
    "result = filter(lambda a: 'i' in a, list1)\n",
    "\n",
    "# convert filter object to a list\n",
    "result_list = [*result]\n",
    "result_list"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Bring it all together(2): try-except"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {},
   "outputs": [],
   "source": [
    "# add try-except block to the function, loca_cal\n",
    "\n",
    "def load_cal(quantity, MOQ = 10, interval = False, interval_unit = 0):\n",
    "    \"\"\"Calculate the quantity to satisfy minimum order quantity.\"\"\"\n",
    "    \n",
    "    # add try block\n",
    "    try:\n",
    "        \n",
    "        # calculate a quantity meeting MOQ\n",
    "        if interval is True:\n",
    "            new_quantity = MOQ + (interval_unit * (int((quantity - MOQ)/interval_unit) + 1))\n",
    "\n",
    "        else:\n",
    "            new_quantity = MOQ * (int(quantity/MOQ) + 1)\n",
    "        return new_quantity\n",
    "    \n",
    "    # add except block\n",
    "    except:\n",
    "        print('quantity, MOQ, and interval_unit should be integer')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "quantity, MOQ, and interval_unit should be integer\n"
     ]
    }
   ],
   "source": [
    "load_cal('3')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Bringing it all together(3): raise"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "def load_cal(quantity, MOQ = 10, interval = False, interval_unit = 0):\n",
    "    \"\"\"Calculate the quantity to satisfy minimum order quantity.\"\"\"\n",
    "    \n",
    "    # Raise a ValueError if quantity, MOQ and interval_unit are below 0\n",
    "    if quantity | MOQ | interval_unit < 0:\n",
    "        raise ValueError('quantity, MOQ, and interval_unit should be greater than or equal to 0')\n",
    "    \n",
    "    # calculate a quantity meeting MOQ\n",
    "    if interval is True:\n",
    "        new_quantity = MOQ + (interval_unit * (int((quantity - MOQ)/interval_unit) + 1))\n",
    "\n",
    "    else:\n",
    "        new_quantity = MOQ * (int(quantity/MOQ) + 1)\n",
    "    return new_quantity\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "metadata": {},
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "quantity, MOQ, and interval_unit should be greater than or equal to 0",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-89-6de1354ab002>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mload_cal\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m10\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mMOQ\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m-\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m<ipython-input-86-aa14a56accb8>\u001b[0m in \u001b[0;36mload_cal\u001b[0;34m(quantity, MOQ, interval, interval_unit)\u001b[0m\n\u001b[1;32m      4\u001b[0m     \u001b[0;31m# Raise a ValueError if quantity, MOQ and interval_unit are below 0\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mquantity\u001b[0m \u001b[0;34m|\u001b[0m \u001b[0mMOQ\u001b[0m \u001b[0;34m|\u001b[0m \u001b[0minterval_unit\u001b[0m \u001b[0;34m<\u001b[0m \u001b[0;36m0\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 6\u001b[0;31m         \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'quantity, MOQ, and interval_unit should be greater than or equal to 0'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      7\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      8\u001b[0m     \u001b[0;31m# calculate a quantity meeting MOQ\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mValueError\u001b[0m: quantity, MOQ, and interval_unit should be greater than or equal to 0"
     ]
    }
   ],
   "source": [
    "load_cal(10, MOQ = -1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
